{"ast":null,"code":"import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck\";\nimport { assert } from \"../core/util/Debug\";\nimport { Signal } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\n\nexport class WaveShaper extends SignalOperator {\n  constructor() {\n    super(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n    this.name = \"WaveShaper\";\n    /**\n     * the waveshaper node\n     */\n\n    this._shaper = this.context.createWaveShaper();\n    /**\n     * The input to the waveshaper node.\n     */\n\n    this.input = this._shaper;\n    /**\n     * The output from the waveshaper node\n     */\n\n    this.output = this._shaper;\n    const options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n\n    if (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n      this.curve = Float32Array.from(options.mapping);\n    } else if (isFunction(options.mapping)) {\n      this.setMap(options.mapping, options.length);\n    }\n  }\n\n  static getDefaults() {\n    return Object.assign(Signal.getDefaults(), {\n      length: 1024\n    });\n  }\n  /**\n   * Uses a mapping function to set the value of the curve.\n   * @param mapping The function used to define the values.\n   *                The mapping function take two arguments:\n   *                the first is the value at the current position\n   *                which goes from -1 to 1 over the number of elements\n   *                in the curve array. The second argument is the array position.\n   * @example\n   * const shaper = new Tone.WaveShaper();\n   * // map the input signal from [-1, 1] to [0, 10]\n   * shaper.setMap((val, index) => (val + 1) * 5);\n   */\n\n\n  setMap(mapping) {\n    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;\n    const array = new Float32Array(length);\n\n    for (let i = 0, len = length; i < len; i++) {\n      const normalized = i / (len - 1) * 2 - 1;\n      array[i] = mapping(normalized, i);\n    }\n\n    this.curve = array;\n    return this;\n  }\n  /**\n   * The array to set as the waveshaper curve. For linear curves\n   * array length does not make much difference, but for complex curves\n   * longer arrays will provide smoother interpolation.\n   */\n\n\n  get curve() {\n    return this._shaper.curve;\n  }\n\n  set curve(mapping) {\n    this._shaper.curve = mapping;\n  }\n  /**\n   * Specifies what type of oversampling (if any) should be used when\n   * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n   */\n\n\n  get oversample() {\n    return this._shaper.oversample;\n  }\n\n  set oversample(oversampling) {\n    const isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n    assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n    this._shaper.oversample = oversampling;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._shaper.disconnect();\n\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"AACA,SAASA,oBAAT,QAAqC,uBAArC;AACA,SAASC,OAAT,EAAkBC,UAAlB,QAAoC,wBAApC;AACA,SAASC,MAAT,QAAuB,oBAAvB;AACA,SAASC,MAAT,QAAuB,UAAvB;AACA,SAASC,cAAT,QAA+B,kBAA/B;AAYA;;;;;;;;;;;;AAWA,OAAM,MAAOC,UAAP,SAA0BD,cAA1B,CAA2D;EAiChEE;IACC,MAAMC,MAAM,CAACC,MAAP,CAAcT,oBAAoB,CAACM,UAAU,CAACI,WAAX,EAAD,EAA2BC,SAA3B,EAAsC,CAAC,SAAD,EAAY,QAAZ,CAAtC,CAAlC,CAAN;IAhCQ,YAAe,YAAf;IAET;;;;IAGQ,eAA0B,KAAKC,OAAL,CAAaC,gBAAb,EAA1B;IAER;;;;IAGA,aAAQ,KAAKC,OAAb;IAEA;;;;IAGA,cAAS,KAAKA,OAAd;IAkBC,MAAMC,OAAO,GAAGf,oBAAoB,CAACM,UAAU,CAACI,WAAX,EAAD,EAA2BC,SAA3B,EAAsC,CAAC,SAAD,EAAY,QAAZ,CAAtC,CAApC;;IAEA,IAAIV,OAAO,CAACc,OAAO,CAACC,OAAT,CAAP,IAA4BD,OAAO,CAACC,OAAR,YAA2BC,YAA3D,EAAyE;MACxE,KAAKC,KAAL,GAAaD,YAAY,CAACE,IAAb,CAAkBJ,OAAO,CAACC,OAA1B,CAAb;IACA,CAFD,MAEO,IAAId,UAAU,CAACa,OAAO,CAACC,OAAT,CAAd,EAAiC;MACvC,KAAKI,MAAL,CAAYL,OAAO,CAACC,OAApB,EAA6BD,OAAO,CAACM,MAArC;IACA;EACD;;EAEiB,OAAXX,WAAW;IACjB,OAAOF,MAAM,CAACC,MAAP,CAAcL,MAAM,CAACM,WAAP,EAAd,EAAoC;MAC1CW,MAAM,EAAE;IADkC,CAApC,CAAP;EAGA;EAED;;;;;;;;;;;;;;EAYAD,MAAM,CAACJ,OAAD,EAA4C;IAAA,IAAbK,MAAa,uEAAJ,IAAI;IACjD,MAAMC,KAAK,GAAG,IAAIL,YAAJ,CAAiBI,MAAjB,CAAd;;IACA,KAAK,IAAIE,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGH,MAAtB,EAA8BE,CAAC,GAAGC,GAAlC,EAAuCD,CAAC,EAAxC,EAA4C;MAC3C,MAAME,UAAU,GAAIF,CAAC,IAAIC,GAAG,GAAG,CAAV,CAAF,GAAkB,CAAlB,GAAsB,CAAzC;MACAF,KAAK,CAACC,CAAD,CAAL,GAAWP,OAAO,CAACS,UAAD,EAAaF,CAAb,CAAlB;IACA;;IACD,KAAKL,KAAL,GAAaI,KAAb;IACA,OAAO,IAAP;EACA;EAED;;;;;;;EAKS,IAALJ,KAAK;IACR,OAAO,KAAKJ,OAAL,CAAaI,KAApB;EACA;;EAEQ,IAALA,KAAK,CAACF,OAAD,EAA6B;IACrC,KAAKF,OAAL,CAAaI,KAAb,GAAqBF,OAArB;EACA;EAED;;;;;;EAIc,IAAVU,UAAU;IACb,OAAO,KAAKZ,OAAL,CAAaY,UAApB;EACA;;EAEa,IAAVA,UAAU,CAACC,YAAD,EAA6B;IAC1C,MAAMC,gBAAgB,GAAG,CAAC,MAAD,EAAS,IAAT,EAAe,IAAf,EAAqBC,IAArB,CAA0BC,GAAG,IAAIA,GAAG,CAACC,QAAJ,CAAaJ,YAAb,CAAjC,CAAzB;IACAxB,MAAM,CAACyB,gBAAD,EAAmB,mDAAnB,CAAN;IACA,KAAKd,OAAL,CAAaY,UAAb,GAA0BC,YAA1B;EACA;EAED;;;;;EAGAK,OAAO;IACN,MAAMA,OAAN;;IACA,KAAKlB,OAAL,CAAamB,UAAb;;IACA,OAAO,IAAP;EACA;;AA1G+D","names":["optionsFromArguments","isArray","isFunction","assert","Signal","SignalOperator","WaveShaper","constructor","Object","assign","getDefaults","arguments","context","createWaveShaper","_shaper","options","mapping","Float32Array","curve","from","setMap","length","array","i","len","normalized","oversample","oversampling","isOverSampleType","some","str","includes","dispose","disconnect"],"sourceRoot":"","sources":["../../../Tone/signal/WaveShaper.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}