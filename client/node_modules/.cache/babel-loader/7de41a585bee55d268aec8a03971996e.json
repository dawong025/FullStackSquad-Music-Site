{"ast":null,"code":"import { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { assert, warn } from \"../util/Debug\";\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\n\nexport class ToneAudioNode extends ToneWithContext {\n  constructor() {\n    super(...arguments);\n    /**\n     * The name of the class\n     */\n\n    this.name = \"ToneAudioNode\";\n    /**\n     * List all of the node that must be set to match the ChannelProperties\n     */\n\n    this._internalChannels = [];\n  }\n  /**\n   * The number of inputs feeding into the AudioNode.\n   * For source nodes, this will be 0.\n   * @example\n   * const node = new Tone.Gain();\n   * console.log(node.numberOfInputs);\n   */\n\n\n  get numberOfInputs() {\n    if (isDefined(this.input)) {\n      if (isAudioParam(this.input) || this.input instanceof Param) {\n        return 1;\n      } else {\n        return this.input.numberOfInputs;\n      }\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The number of outputs of the AudioNode.\n   * @example\n   * const node = new Tone.Gain();\n   * console.log(node.numberOfOutputs);\n   */\n\n\n  get numberOfOutputs() {\n    if (isDefined(this.output)) {\n      return this.output.numberOfOutputs;\n    } else {\n      return 0;\n    }\n  } //-------------------------------------\n  // AUDIO PROPERTIES\n  //-------------------------------------\n\n  /**\n   * Used to decide which nodes to get/set properties on\n   */\n\n\n  _isAudioNode(node) {\n    return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n  }\n  /**\n   * Get all of the audio nodes (either internal or input/output) which together\n   * make up how the class node responds to channel input/output\n   */\n\n\n  _getInternalNodes() {\n    const nodeList = this._internalChannels.slice(0);\n\n    if (this._isAudioNode(this.input)) {\n      nodeList.push(this.input);\n    }\n\n    if (this._isAudioNode(this.output)) {\n      if (this.input !== this.output) {\n        nodeList.push(this.output);\n      }\n    }\n\n    return nodeList;\n  }\n  /**\n   * Set the audio options for this node such as channelInterpretation\n   * channelCount, etc.\n   * @param options\n   */\n\n\n  _setChannelProperties(options) {\n    const nodeList = this._getInternalNodes();\n\n    nodeList.forEach(node => {\n      node.channelCount = options.channelCount;\n      node.channelCountMode = options.channelCountMode;\n      node.channelInterpretation = options.channelInterpretation;\n    });\n  }\n  /**\n   * Get the current audio options for this node such as channelInterpretation\n   * channelCount, etc.\n   */\n\n\n  _getChannelProperties() {\n    const nodeList = this._getInternalNodes();\n\n    assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\"); // use the first node to get properties\n    // they should all be the same\n\n    const node = nodeList[0];\n    return {\n      channelCount: node.channelCount,\n      channelCountMode: node.channelCountMode,\n      channelInterpretation: node.channelInterpretation\n    };\n  }\n  /**\n   * channelCount is the number of channels used when up-mixing and down-mixing\n   * connections to any inputs to the node. The default value is 2 except for\n   * specific nodes where its value is specially determined.\n   */\n\n\n  get channelCount() {\n    return this._getChannelProperties().channelCount;\n  }\n\n  set channelCount(channelCount) {\n    const props = this._getChannelProperties(); // merge it with the other properties\n\n\n    this._setChannelProperties(Object.assign(props, {\n      channelCount\n    }));\n  }\n  /**\n   * channelCountMode determines how channels will be counted when up-mixing and\n   * down-mixing connections to any inputs to the node.\n   * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n   * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n   * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n   * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n   */\n\n\n  get channelCountMode() {\n    return this._getChannelProperties().channelCountMode;\n  }\n\n  set channelCountMode(channelCountMode) {\n    const props = this._getChannelProperties(); // merge it with the other properties\n\n\n    this._setChannelProperties(Object.assign(props, {\n      channelCountMode\n    }));\n  }\n  /**\n   * channelInterpretation determines how individual channels will be treated\n   * when up-mixing and down-mixing connections to any inputs to the node.\n   * The default value is \"speakers\".\n   */\n\n\n  get channelInterpretation() {\n    return this._getChannelProperties().channelInterpretation;\n  }\n\n  set channelInterpretation(channelInterpretation) {\n    const props = this._getChannelProperties(); // merge it with the other properties\n\n\n    this._setChannelProperties(Object.assign(props, {\n      channelInterpretation\n    }));\n  } //-------------------------------------\n  // CONNECTIONS\n  //-------------------------------------\n\n  /**\n   * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n   * @param destination The output to connect to\n   * @param outputNum The output to connect from\n   * @param inputNum The input to connect to\n   */\n\n\n  connect(destination) {\n    let outputNum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let inputNum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    connect(this, destination, outputNum, inputNum);\n    return this;\n  }\n  /**\n   * Connect the output to the context's destination node.\n   * @example\n   * const osc = new Tone.Oscillator(\"C2\").start();\n   * osc.toDestination();\n   */\n\n\n  toDestination() {\n    this.connect(this.context.destination);\n    return this;\n  }\n  /**\n   * Connect the output to the context's destination node.\n   * See [[toDestination]]\n   * @deprecated\n   */\n\n\n  toMaster() {\n    warn(\"toMaster() has been renamed toDestination()\");\n    return this.toDestination();\n  }\n  /**\n   * disconnect the output\n   */\n\n\n  disconnect(destination) {\n    let outputNum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let inputNum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    disconnect(this, destination, outputNum, inputNum);\n    return this;\n  }\n  /**\n   * Connect the output of this node to the rest of the nodes in series.\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3\");\n   * player.autostart = true;\n   * const filter = new Tone.AutoFilter(4).start();\n   * const distortion = new Tone.Distortion(0.5);\n   * // connect the player to the filter, distortion and then to the master output\n   * player.chain(filter, distortion, Tone.Destination);\n   */\n\n\n  chain() {\n    for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {\n      nodes[_key] = arguments[_key];\n    }\n\n    connectSeries(this, ...nodes);\n    return this;\n  }\n  /**\n   * connect the output of this node to the rest of the nodes in parallel.\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n   * player.autostart = true;\n   * const pitchShift = new Tone.PitchShift(4).toDestination();\n   * const filter = new Tone.Filter(\"G5\").toDestination();\n   * // connect a node to the pitch shift and filter in parallel\n   * player.fan(pitchShift, filter);\n   */\n\n\n  fan() {\n    for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      nodes[_key2] = arguments[_key2];\n    }\n\n    nodes.forEach(node => this.connect(node));\n    return this;\n  }\n  /**\n   * Dispose and disconnect\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    if (isDefined(this.input)) {\n      if (this.input instanceof ToneAudioNode) {\n        this.input.dispose();\n      } else if (isAudioNode(this.input)) {\n        this.input.disconnect();\n      }\n    }\n\n    if (isDefined(this.output)) {\n      if (this.output instanceof ToneAudioNode) {\n        this.output.dispose();\n      } else if (isAudioNode(this.output)) {\n        this.output.disconnect();\n      }\n    }\n\n    this._internalChannels = [];\n    return this;\n  }\n\n} //-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\n\nexport function connectSeries() {\n  for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    nodes[_key3] = arguments[_key3];\n  }\n\n  const first = nodes.shift();\n  nodes.reduce((prev, current) => {\n    if (prev instanceof ToneAudioNode) {\n      prev.connect(current);\n    } else if (isAudioNode(prev)) {\n      connect(prev, current);\n    }\n\n    return current;\n  }, first);\n}\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\nexport function connect(srcNode, dstNode) {\n  let outputNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let inputNumber = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  assert(isDefined(srcNode), \"Cannot connect from undefined node\");\n  assert(isDefined(dstNode), \"Cannot connect to undefined node\");\n\n  if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n    assert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n  }\n\n  assert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\"); // resolve the input of the dstNode\n\n  while (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {\n    if (isDefined(dstNode.input)) {\n      dstNode = dstNode.input;\n    }\n  }\n\n  while (srcNode instanceof ToneAudioNode) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  } // make the connection\n\n\n  if (isAudioParam(dstNode)) {\n    srcNode.connect(dstNode, outputNumber);\n  } else {\n    srcNode.connect(dstNode, outputNumber, inputNumber);\n  }\n}\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\nexport function disconnect(srcNode, dstNode) {\n  let outputNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let inputNumber = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  // resolve the destination node\n  if (isDefined(dstNode)) {\n    while (dstNode instanceof ToneAudioNode) {\n      dstNode = dstNode.input;\n    }\n  } // resolve the src node\n\n\n  while (!isAudioNode(srcNode)) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  }\n\n  if (isAudioParam(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber);\n  } else if (isAudioNode(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber, inputNumber);\n  } else {\n    srcNode.disconnect();\n  }\n}","map":{"version":3,"mappings":"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","names":["isAudioNode","isAudioParam","isDefined","Param","ToneWithContext","assert","warn","ToneAudioNode","constructor","numberOfInputs","input","numberOfOutputs","output","_isAudioNode","node","_getInternalNodes","nodeList","_internalChannels","slice","push","_setChannelProperties","options","forEach","channelCount","channelCountMode","channelInterpretation","_getChannelProperties","length","props","Object","assign","connect","destination","outputNum","inputNum","toDestination","context","toMaster","disconnect","chain","nodes","connectSeries","fan","dispose","first","shift","reduce","prev","current","srcNode","dstNode","outputNumber","inputNumber"],"sourceRoot":"","sources":["../../../../Tone/core/context/ToneAudioNode.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}