{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { connect, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.\n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\n\nexport class UserMedia extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n    this.name = \"UserMedia\";\n    const options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n    this._volume = this.output = new Volume({\n      context: this.context,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume;\n    readOnly(this, \"volume\");\n    this.mute = options.mute;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      volume: 0\n    });\n  }\n  /**\n   * Open the media stream. If a string is passed in, it is assumed\n   * to be the label or id of the stream, if a number is passed in,\n   * it is the input number of the stream.\n   * @param  labelOrId The label or id of the audio input media device.\n   *                   With no argument, the default stream is opened.\n   * @return The promise is resolved when the stream is open.\n   */\n\n\n  open(labelOrId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(UserMedia.supported, \"UserMedia is not supported\"); // close the previous stream\n\n      if (this.state === \"started\") {\n        this.close();\n      }\n\n      const devices = yield UserMedia.enumerateDevices();\n\n      if (isNumber(labelOrId)) {\n        this._device = devices[labelOrId];\n      } else {\n        this._device = devices.find(device => {\n          return device.label === labelOrId || device.deviceId === labelOrId;\n        }); // didn't find a matching device\n\n        if (!this._device && devices.length > 0) {\n          this._device = devices[0];\n        }\n\n        assert(isDefined(this._device), `No matching device ${labelOrId}`);\n      } // do getUserMedia\n\n\n      const constraints = {\n        audio: {\n          echoCancellation: false,\n          sampleRate: this.context.sampleRate,\n          noiseSuppression: false,\n          mozNoiseSuppression: false\n        }\n      };\n\n      if (this._device) {\n        // @ts-ignore\n        constraints.audio.deviceId = this._device.deviceId;\n      }\n\n      const stream = yield navigator.mediaDevices.getUserMedia(constraints); // start a new source only if the previous one is closed\n\n      if (!this._stream) {\n        this._stream = stream; // Wrap a MediaStreamSourceNode around the live input stream.\n\n        const mediaStreamNode = this.context.createMediaStreamSource(stream); // Connect the MediaStreamSourceNode to a gate gain node\n\n        connect(mediaStreamNode, this.output);\n        this._mediaStream = mediaStreamNode;\n      }\n\n      return this;\n    });\n  }\n  /**\n   * Close the media stream\n   */\n\n\n  close() {\n    if (this._stream && this._mediaStream) {\n      this._stream.getAudioTracks().forEach(track => {\n        track.stop();\n      });\n\n      this._stream = undefined; // remove the old media stream\n\n      this._mediaStream.disconnect();\n\n      this._mediaStream = undefined;\n    }\n\n    this._device = undefined;\n    return this;\n  }\n  /**\n   * Returns a promise which resolves with the list of audio input devices available.\n   * @return The promise that is resolved with the devices\n   * @example\n   * Tone.UserMedia.enumerateDevices().then((devices) => {\n   * \t// print the device labels\n   * \tconsole.log(devices.map(device => device.label));\n   * });\n   */\n\n\n  static enumerateDevices() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const allDevices = yield navigator.mediaDevices.enumerateDevices();\n      return allDevices.filter(device => {\n        return device.kind === \"audioinput\";\n      });\n    });\n  }\n  /**\n   * Returns the playback state of the source, \"started\" when the microphone is open\n   * and \"stopped\" when the mic is closed.\n   */\n\n\n  get state() {\n    return this._stream && this._stream.active ? \"started\" : \"stopped\";\n  }\n  /**\n   * Returns an identifier for the represented device that is\n   * persisted across sessions. It is un-guessable by other applications and\n   * unique to the origin of the calling application. It is reset when the\n   * user clears cookies (for Private Browsing, a different identifier is\n   * used that is not persisted across sessions). Returns undefined when the\n   * device is not open.\n   */\n\n\n  get deviceId() {\n    if (this._device) {\n      return this._device.deviceId;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Returns a group identifier. Two devices have the\n   * same group identifier if they belong to the same physical device.\n   * Returns null  when the device is not open.\n   */\n\n\n  get groupId() {\n    if (this._device) {\n      return this._device.groupId;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Returns a label describing this device (for example \"Built-in Microphone\").\n   * Returns undefined when the device is not open or label is not available\n   * because of permissions.\n   */\n\n\n  get label() {\n    if (this._device) {\n      return this._device.label;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Mute the output.\n   * @example\n   * const mic = new Tone.UserMedia();\n   * mic.open().then(() => {\n   * \t// promise resolves when input is available\n   * });\n   * // mute the output\n   * mic.mute = true;\n   */\n\n\n  get mute() {\n    return this._volume.mute;\n  }\n\n  set mute(mute) {\n    this._volume.mute = mute;\n  }\n\n  dispose() {\n    super.dispose();\n    this.close();\n\n    this._volume.dispose();\n\n    this.volume.dispose();\n    return this;\n  }\n  /**\n   * If getUserMedia is supported by the browser.\n   */\n\n\n  static get supported() {\n    return isDefined(navigator.mediaDevices) && isDefined(navigator.mediaDevices.getUserMedia);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["connect","ToneAudioNode","Volume","optionsFromArguments","assert","readOnly","isDefined","isNumber","UserMedia","constructor","getDefaults","arguments","options","_volume","output","context","volume","mute","Object","assign","open","labelOrId","supported","state","close","devices","enumerateDevices","_device","find","device","label","deviceId","length","constraints","audio","echoCancellation","sampleRate","noiseSuppression","mozNoiseSuppression","stream","navigator","mediaDevices","getUserMedia","_stream","mediaStreamNode","createMediaStreamSource","_mediaStream","getAudioTracks","forEach","track","stop","undefined","disconnect","allDevices","filter","kind","active","groupId","dispose"],"sourceRoot":"","sources":["../../../Tone/source/UserMedia.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}